/* This file is part of MODEL, the Mechanics Of Defect Evolution Library.
 *
 * Copyright (C) 2011 by Giacomo Po <gpo@ucla.edu>.
 *
 * model is distributed without any warranty under the
 * GNU General Public License (GPL) v2 <http://www.gnu.org/licenses/>.
 */

#ifndef _model_DislocationDisplacement_h_
#define _model_DislocationDisplacement_h_

#include <FieldBase.h>
#include <DislocationStress.h>


namespace model
{
	
	/**************************************************************************/
	/**************************************************************************/
    /*!\brief Class template which implements the calculation of the displacement
     * field generated by the dislocation network.
     *
     * The displacement field of a dislocation loops is calculated according to the equation:
     \f[
     \begin{align}
     \mathbf{u}(\mathbf x)=-\frac{\mathbf{ b}\Omega(\mathbf x)}{4\pi}-\frac{1}{8\pi(1-\nu)}\oint_\mathcal{L}&\frac{1}{R}\left\{\
     \left(1-2\nu\right) \mathbf{ b}\times\hat{\mathbf{ \xi}}'
     + \left[\hat{\mathbf{ R}}\cdot\left(\mathbf{ b}\times\hat{\mathbf{ \xi}}' \right) \right]\hat{\mathbf{ R}}  \right\}\ dL'
     \end{align}
     \f]
     where \f$\mathbf{R}=\mathbf x-\mathbf x'\f$, and  \f$\Omega(\mathbf x)\f$ is the solid angle subtended by the surface \f$\mathcal{S}\f$:
     \f[
     \begin{align}
     \Omega(\mathbf{x})=\int_\mathcal{S}\left(-\frac{1}{2}\partial_k\Delta R\right)\ dA'_k=\int_\mathcal{S} v_k(\mathbf R)\ dA'_k&&v_k(\mathbf y)=\frac{y_k}{y^3}
     \end{align}
     \f]
     We now derive the line integral expression for the solid angle. The derivation follows from [1].
     In order to transform the solid angle into a line integral, we need to introduce a fictitious vector field \f$v_k^f(\mathbf R)\f$ with the property \f$v^f_{k,k}=-v_{k,k}\f$.
     In this way we can find a vector potential \f$\Psi_m(\mathbf{R})\f$ for the divergence-less sum \f$v_k+v^f_k\f$.
     The vector potential satisfies both \f$v_k+v^f_k=\epsilon_{klm}\Psi_{m,l}\f$, and \f$\Psi_{k,k}=0\f$. Therefore, using Stokes theorem, we can write
     \f[
     \begin{align}
     \Omega(\mathbf{x})&=\int_\mathcal{S} \left(\epsilon_{klm}\Psi_{m,l}-v^f_k\right)\ dA'_k=\int_\mathcal{S} \left(-\epsilon_{klm}\Psi_{m,l'}-v^f_k\right)\ dA'_k\nonumber\\
     &=-\oint_\mathcal{L}\Psi_m\ dL'_m-\int_\mathcal{S} v^f_k\ dA'_k=-\oint_\mathcal{L}\Psi_i\ dL'_i-\Omega^f
     \end{align}
     \f]
     We now need to find the vector potential \f$\Psi_i\f$ and the fictitious vector field \f$v_i^f\f$.
     To do this we consider the auxiliary curve (Dirac string) \f$\mathcal{D}\f$, starting from \f$\mathbf x\f$ and ending at a point at infinity.
     Using the Dirac string, the fictitious vector can be found as
     \f[
     \begin{align}
     v^f_{k}(\mathbf{R})=\int_\mathcal{D}v_{m,m}(\mathbf{R}+\mathbf{s})ds_k
     =\int_\mathcal{D}\left(-\frac{1}{2}\Delta\Delta |\mathbf{x}+\mathbf{s}|\right)ds_k
     =4\pi\int_\mathcal{D}\delta(\mathbf{R}+\mathbf{s})ds_k
     \end{align}
     \f]
     The aforementioned property of \f$\mathbf v^f\f$ can be verified as follows:
     \f[
     \begin{align}
     v^f_{k,k}(\mathbf{R})
     &=\frac{\partial}{\partial x_k}\int_\mathcal{D}v_{m,m}(\mathbf{R}+\mathbf{s})ds_k
     =\int_\mathcal{D}\frac{\partial}{\partial x_k}v_{m,m}(\mathbf{R}+\mathbf{s})ds_k\nonumber\\
     &=\int_\mathcal{D}\frac{\partial}{\partial s_k}v_{m,m}(\mathbf{R}+\mathbf{s})ds_k
     =\left[v_{m,m}(\mathbf{R}+\mathbf{s})\right]_\mathbf{0}^\infty=-v_{m,m}(\mathbf{R})
     \end{align}
     \f]
     
     Knowing the fictitious vector, the vector potential can be found observing that
     \f[
     \begin{align}
     -\Delta \Psi_i=\epsilon_{ijk}(v_k+v^f_k)_{,j}=\epsilon_{ijk}v^f_{k,j}=-\epsilon_{ijk}\partial_j\int_\mathcal{D}\frac{1}{2}\Delta\Delta |\mathbf{R}+\mathbf{s}|ds_k
     \end{align}
     \f]
     Therefore
     \f[
     \begin{align}
     \Psi_i(\mathbf R)=\epsilon_{ijk}\int_\mathcal{D}\frac{1}{2}\partial_j\Delta |\mathbf{R}+\mathbf{s}|ds_k=-\epsilon_{ijk}\int_\mathcal{D}\frac{R_j+s_j}{|\mathbf{R}+\mathbf{s}|^3}ds_k
     \end{align}
     \f]
     Choosing the Dirac string to be a straight line with unit direction \f$\hat{\mathbf{s}}\f$, the expression above becomes:
     \f[
     \begin{align}
     \Psi_i(\mathbf R)&
     =-\epsilon_{ijk}\int_0^\infty\frac{R_j+\alpha \hat{s}_j}{|\mathbf{R}+\alpha\hat{\mathbf{s}}|^3}\hat{s}_k\ d\alpha
     =-\epsilon_{ijk}R_j\hat{s}_k\int_0^\infty\frac{1}{|\mathbf{R}+\alpha\hat{\mathbf{s}}|^3}\ d\alpha\nonumber\\
     &=-\epsilon_{ijk}R_j\hat{s}_k\left[\frac{\alpha+\mathbf{R}\cdot\hat{\mathbf{s}}}{\left(R^2-(\mathbf{R}\cdot\hat{\mathbf{s}})^2\right)|\mathbf R+\alpha\hat{\mathbf s}|}\right]_0^\infty\nonumber\\
     &=-\epsilon_{ijk}R_j\hat{s}_k\left[\frac{1}{R^2-(\mathbf{R}\cdot\hat{\mathbf{s}})^2}
     -\frac{\mathbf{R}\cdot\hat{\mathbf{s}}}{\left(R^2-(\mathbf{R}\cdot\hat{\mathbf{s}})^2\right)R}\right]\nonumber\\
     &=-\epsilon_{ijk}R_j\hat{s}_k
     \frac{R-\mathbf{R}\cdot\hat{\mathbf{s}}}{\left(R^2-(\mathbf{R}\cdot\hat{\mathbf{s}})^2\right)R}
     =-\frac{\epsilon_{ijk}R_j\hat{s}_k}{R\left(R+\mathbf{R}\cdot\hat{\mathbf{s}}\right)}
     \end{align}
     \f]
     In vector form this reads
     \f[
     \begin{align}
     \mathbf{\Psi}(\mathbf{x})=-\frac{\mathbf{R}\times\hat{\mathbf{s}}}{R\left(R+\mathbf{R}\cdot\hat{\mathbf{s}}\right)}
     \end{align}
     \f]
     
     Finally, the Burgers equation becomes
     \f[
     \begin{align}
     \mathbf{u}(\mathbf x)
     &=-\frac{\mathbf{ b}}{4\pi}\left(-\oint_\mathcal{L}\Psi_i(\mathbf{R})\ dL'_i-\Omega^f\right)-\frac{1}{8\pi(1-\nu)}\oint_\mathcal{L}\frac{1}{R}\left\{\
     \left(1-2\nu\right) \mathbf{ b}\times\hat{\mathbf{ \xi}}'
     + \left[\hat{\mathbf{ R}}\cdot\left(\mathbf{ b}\times\hat{\mathbf{ \xi}}' \right) \right]\hat{\mathbf{ R}}  \right\}\ dL'\nonumber\\
     &=\frac{\mathbf{ b}\Omega^f}{4\pi}
     -\frac{\mathbf{ b}}{4\pi}\oint_\mathcal{L}\frac{(\mathbf{R}\times\hat{\mathbf{s}})\cdot\hat{\mathbf{\xi}}'}{R\left(R+\mathbf{R}\cdot\hat{\mathbf{s}}\right)}\ dL'
     -\frac{1}{8\pi(1-\nu)}\oint_\mathcal{L}\frac{1}{R}\left\{\
     \left(1-2\nu\right) \mathbf{ b}\times\hat{\mathbf{ \xi}}'
     + \left[\hat{\mathbf{ R}}\cdot\left(\mathbf{ b}\times\hat{\mathbf{ \xi}}' \right) \right]\hat{\mathbf{ R}}  \right\}\ dL'\nonumber\\
     &=\mathbf{b}^f(\mathbf x)
     -\frac{1}{8\pi(1-\nu)}\oint_\mathcal{L}
     \frac{1}{R}\left\{\ \frac{2(1-\nu)(\hat{\mathbf{R}}\times\hat{\mathbf{s}})\cdot\hat{\mathbf{\xi}}'}{1+\hat{\mathbf{R}}\cdot\hat{\mathbf{s}}}\mathbf{ b}
     + \left(1-2\nu\right) \mathbf{ b}\times\hat{\mathbf{ \xi}}'
     + \left[\hat{\mathbf{ R}}\cdot\left(\mathbf{ b}\times\hat{\mathbf{ \xi}}' \right) \right]\hat{\mathbf{ R}}  \right\}\ dL'\nonumber\\
     &=\mathbf{b}^f(\mathbf x)
     +\frac{1}{8\pi(1-\nu)}\oint_\mathcal{L}
     \frac{1}{R}\left\{\ \frac{2(1-\nu)(\hat{\mathbf{s}}\times\hat{\mathbf{R}})\cdot\hat{\mathbf{\xi}}'}{1+\hat{\mathbf{R}}\cdot\hat{\mathbf{s}}}\mathbf{ b}
     + \left(1-2\nu\right) \hat{\mathbf{ \xi}}'\times \mathbf{ b}
     + \left[\hat{\mathbf{ R}}\cdot\left(\hat{\mathbf{ \xi}}'\times\mathbf{ b} \right) \right]\hat{\mathbf{ R}}  \right\}\ dL'\nonumber\\
     \end{align}
     \f]
     
     Notice that
     \f[
     \begin{align}
     \mathbf{b}^f(\mathbf x)
     &=\frac{\mathbf{ b}\Omega^f}{4\pi}
     =\frac{\mathbf{ b}}{4\pi}\int_\mathcal{S} v^f_k(\mathbf{R})\ dA'_k
     =\frac{\mathbf{ b}}{4\pi}\int_\mathcal{S} 4\pi\int_\mathcal{D}\delta(\mathbf{R}+\mathbf{s})ds_k\ dA'_k\nonumber\\
     &=\begin{cases}
     +\mathbf{b}&\mbox{if the Dirac string crosses the slip surface positively}\\
     -\mathbf{b}&\mbox{if the Dirac string crosses the slip surface negatively}\\
     \mathbf{0}&\mbox{if the Dirac string does not cross the slip surface }
     \end{cases}
     \end{align}
     \f]
     
     * References:
     *
     * [1] Po, G., Lazar, M., Seif, D., & Ghoniem, N. M. (2014).
     * Singularity-free dislocation dynamics with strain gradient elasticity.
     * Journal of the Mechanics and Physics of Solids, 68, 161â€“178.
     */
	template<short unsigned int _dim>
	struct DislocationDisplacement : public FieldBase<double,_dim,1>
    {
        constexpr static int dim=_dim;
        typedef DislocationDisplacement<_dim> DislocationDisplacementType;
        typedef FieldBase<double,_dim,1> FieldBaseType;
        typedef typename FieldBaseType::MatrixType MatrixType;
        typedef Eigen::Matrix<double,dim,dim> MatrixDim;
        typedef Eigen::Matrix<double,dim,1>   VectorDim;
        typedef DislocatedMaterial<dim,Isotropic> MaterialType;


        static bool use_multipole;
        
        //! The identity matrix
		static const Eigen::Matrix<double,_dim,_dim> I;
        
        
        /**********************************************************************/
        static const MatrixType& get(const MatrixType& temp)
        {
            return temp;
        }
        
        /**********************************************************************/
        template <typename ParticleType, typename CellContainerType>
        static MatrixType multipole(const ParticleType& field,const CellContainerType& farCells)
        {/*!@param[in] field  the FieldPoint at which stress is computed
          * @param[in] farCells container of SpatialCell(s) that are not neighbors of field
          *\returns the displacement contribution of the farCells on field.
          *
          */
            MatrixType temp(MatrixType::Zero());
            for(auto cell : farCells)
            {
#ifdef _MODEL_ENABLE_CELL_VERTEX_ALPHA_TENSORS_
                for(size_t v=0;v<Pow<2,dim>::value;++v)
                {
                VectorDim r(field.P-cell.second->vertices().col(v));
                const double R(r.norm());
                r/=R; // normalize R;
                const MatrixDim& alpha(std::get<1>(*cell.second)[v]);
                const VectorDim a(DislocationStress<dim>::axialVector(alpha));
                temp += (+2.0*MaterialType::C1/(1.0+r.dot(field.S))*alpha*(field.S.cross(r))
                         /*    */ - MaterialType::C3*a
                         /*    */ - a.dot(r)*r)/R;
                }
#else
                VectorDim r(field.P-cell.second->center);
                const double R(r.norm());
                r/=R; // normalize R;
                const MatrixDim& alpha(std::get<1>(*cell.second));
                const VectorDim a(DislocationStress<dim>::axialVector(alpha));
                temp += (+2.0*MaterialType::C1/(1.0+r.dot(field.S))*alpha*(field.S.cross(r))
                         /*    */ - MaterialType::C3*a
                         /*    */ - a.dot(r)*r)/R;
#endif
            }
            return MaterialType::C4*temp; // C4=1/(8*pi*(1-nu))
        }
        
#if _MODEL_NON_SINGULAR_DD_ == 0 // Note that if _MODEL_NON_SINGULAR_DD_ is not #defined, the preprocessor treats it as having the value 0.
        /**********************************************************************/
        template <typename DislocationParticleType, typename OtherParticleType>
        static MatrixType compute(const DislocationParticleType& source,const OtherParticleType& field)
        {/*!@param[in] Rfield	the field point
          * @param[in] S the unit vector necessary to compute displacement as line integral
          * \returns The infinitesimal dispacement field generated by this segment at a field point
          *
          */            
            MatrixType R(field.P-source.P);
			const double Ra=sqrt(R.squaredNorm()+DislocationStress<_dim>::a2);
            R/=Ra; // normalize R
			return (MaterialType::C4*source.quadWeight/Ra) *
            /*  */ (+ 2.0*MaterialType::C1/(1.0+R.dot(field.S))*(field.S.cross(R)).dot(source.T)*source.B
                    /*  */  + MaterialType::C3*source.T.cross(source.B)
                    /*  */  + (source.T.cross(source.B)).dot(R)*R
                    /*  */ );
        }
        
#elif _MODEL_NON_SINGULAR_DD_ == 1 /* Cai's non-singular theory */
        /**********************************************************************/
        template <typename DislocationParticleType, typename OtherParticleType>
        static MatrixType compute(const DislocationParticleType& source,const OtherParticleType& field)
        {/*!@param[in] Rfield	the field point
          * @param[in] S the unit vector necessary to compute displacement as line integral
          * \returns The infinitesimal dispacement field generated by this segment at a field point
          *
          */
            assert(0 && "THE LINE-INTEGRAL REPRESENTATION OF THE SOLID ANGLE FOR CAI'S THEORY HAS NOT BEEN IMPLEMENTED");
			return MatrixType::Zero();
        }
        
#elif _MODEL_NON_SINGULAR_DD_ == 2 /* Lazar's non-singular theory */
        /**********************************************************************/
        template <typename DislocationParticleType, typename OtherParticleType>
        static MatrixType compute(const DislocationParticleType& source,const OtherParticleType& field)
        {/*!@param[in] Rfield	the field point
          * @param[in] S the unit vector necessary to compute displacement as line integral
          * \returns The infinitesimal dispacement field generated by this segment at a field point
          *
          */
            assert(0 && "THE LINE-INTEGRAL REPRESENTATION OF THE SOLID ANGLE FOR LAZAR'S THEORY HAS NOT BEEN IMPLEMENTED");
			return MatrixType::Zero();
        }
        
#else
#error Unsupported choice of field regularization
#endif
        
		
	};
    
    template<short unsigned int _dim>
	bool DislocationDisplacement<_dim>::use_multipole=true;
    
    // Static data
	template<short unsigned int _dim>
	const Eigen::Matrix<double,_dim,_dim> DislocationDisplacement<_dim>::I=Eigen::Matrix<double,_dim,_dim>::Identity();
    
}	// close namespace
#endif
